/**
 * @file Bracery API Wrapper
 *
 * A module to simplify using the Bracery module
 * @see https://github.com/ihh/bracery
 *
 * @module braceryAID
 *
 * @requires fs
 * @requires path
 * @requires is-valid-path
 * @requires bracery
 * @requires dotenv
 *
 * @version 0.0.1
 * @copyright 2020
 */

require('dotenv').config()
const fs = require('fs')
const path = require('path')
const bracery = require('bracery')
const braceryUserExtensions = require('./braceryUserExtensions')

// * Bracery grammars directory path (note this is also duplicated in 'braceryUserExtensions')
const braceryLibraryPath = './src/lib/bracery_grammars/'

/**
 * charMap are the valid symbols that the plain txt file the Bracery parse function can consume.
 */
/*
const charMap = {
  symChar: '~',
  varChar: '$',
  funcChar: '&',
  leftBraceChar: '{',
  rightBraceChar: '}',
  leftSquareBraceChar: '[',
  rightSquareBraceChar: ']',
  pipeChar: '|',
  assignChar: '=',
  traceryChar: '#',
  defaultMapVar: '_',
}
*/

/**
 * convert rule text to bracery object
 * @param {string} ruleTxt
 * @returns {object} - bracery rules object
 */
const convertTxt = ruleTxt => bracery.ParseTree.parseTextDefs(ruleTxt)

/**
 * initialise a new Bracery instance
 *
 * Init function can be passed txt/json/js files or a Bracery Rules Object
 *
 * @example
 *
 * const braceryAID = require('path/to/braceryAID.js')
 *
 * const a = braceryAID.init('./src/lib/exampleB.txt')
 * const b = braceryAID.init('./src/lib/exampleA.js')
 * const c = braceryAID.init('./src/lib/exampleB.json')
 * const dRules = require('../lib/exampleA')
 * const d = braceryAID.init(dRules)
 *
 * // No initial rules required & Custom User Extensions are pre-installed
 * const e = init()
 * console.log(e.expand('&eval{~testCustomExtension}').text)
 *
 * @param {object | string} [rulesOrFilePath = {}] - bracery rules input as object, txt or file path (txt, json or js)
 * @returns {object} - bracery instance
 */
const init = (rulesOrFilePath = {}) => {
  let rules = rulesOrFilePath
  if (typeof rulesOrFilePath === 'string') {
    const filePath = rulesOrFilePath
    const extName = path.extname(filePath)
    // if we have a txt file
    if (extName === '.txt' || extName === '') {
      let file = fs.readFileSync(filePath, 'utf-8')
      rules = convertTxt(file)
    }
    // if we have a js or json file presume its an import
    if (extName === '.js' || extName === '.json') {
      rules = require(path.resolve(process.cwd(), filePath))
    }
  }
  if (typeof rules !== 'object') {
    throw Error('incorrect argument passed to BraceryAID.init()')
  }
  // hand the converted text or json object to Bracery and pass back an instance
  const bInstance = new bracery.Bracery(rules)

  // load all custom user extensions
  const customUserExtensions = braceryUserExtensions(bInstance)
  bInstance.addRules(customUserExtensions)

  // add memory slot for custom storage
  bInstance.aid = {}

  return bInstance
}

/**
 * expander
 * @param {object} braceryInstance - bracery instance
 * @param {string} startTerminal - start terminal to kick off expansion
 * @returns {promise<string>} - returns the text expansion
 */
const expand = (braceryInstance, startTerminal) => {
  return new Promise(resolve => {
    braceryInstance.expand(startTerminal, {
      callback: expansion => {
        resolve(expansion.text)
      },
    })
  })
}

/**
 * trimmer
 * @param {string} txt - trim down the execess space between text
 */
const trim = txt => txt.replace(/[^\S\r\n]+/g, ' ').trim()

/**
 * log shorthand
 * @param {string} cmd - bracery txt command to expand
 */
const log = (aid, b, show = false) => async cmd => {
  const output = aid.trim(await aid.expand(b, cmd))
  if (show) console.log(output)
  return output
}

/**
 * Create a grammar plain text file from an object of lists
 * filename is autogenerated from first property of the object
 * @param {{filename: string, data: {[string]: string[]}}} dataObj - object of properties holding arrays
 */
const dataToGrammarFile = ({ filename, data }) => {
  let txt = ''

  // iterate over each key for a new list to append to file
  for (let key in data) {
    // convert any raw single values to an array so we don't error
    if (!Array.isArray(data[key])) data[key] = [data[key]]

    txt += `>${key}\n`
    data[key].forEach(val => (txt += val + '\n'))
    txt += '\n'
  }

  fs.writeFileSync(
    path.join(braceryLibraryPath, 'auto', `${filename}.txt`),
    txt
  )
}

/**
 * convert bracery plain text in to a data object
 * @param {string} filepath - filepath of bracery plain txt file
 * @returns {object} - object where properties are holding lists
 */
const grammarFileToData = filepath => {
  const rows = fs
    .readFileSync(path.resolve(process.cwd(), filepath), 'utf8')
    .trim()
    .split('\n')
    .filter(row => row.length)

  // iterate over the rows constructing an object
  let currKey
  let data = {}

  rows.forEach(row => {
    if (row.includes('>')) {
      currKey = row.slice(1)
      data[currKey] = []
    } else {
      data[currKey] = [...data[currKey], row]
    }
  })

  return data
}

module.exports = {
  init,
  convertTxt,
  expand,
  trim,
  log,
  dataToGrammarFile,
  grammarFileToData,
}
